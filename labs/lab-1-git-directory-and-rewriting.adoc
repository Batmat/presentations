= Twiddling with .git directory and the history
:source-language: console
:toc: right
:sectnums:

== The .git directory

TIP: Use the link:../resources/lab/gitrepository-layout.html[provided documentation if needed]

=== ls .git!

* Create a new Git repository (wherever you want)

  git init repo && cd repo && git commit -m 'Initial' --allow-empty

* List the .git directory content and have a look.
* Create a branch _newbranch_, what (and where) did it create inside the .git directory?

  git branch newbranch

* Checkout that branch, then have a look inside `.git/logs/` :
** What is this directory used for?

** Which git command does actually use that directory? 
   (hint: use `git help -a` if needed to find out, then `git help <COMMAND>`)

* Have a look inside `.git/refs`

[source]
ls -l .git/refs/*/*

** What is this directory used for?

=== Playing with the data model

In a Git repository, execute precisely the following commands to create a commit with a new file:

[source]
echo "Hi Eclipse Con France 2015" > pof
git add pof
git commit -m "commit done"

If your OS is Linux/Mac based, execute the following command :

[source]
echo -e "blob 27\0Hi Eclipse Con France 2015" | shasum

CAUTION: For Windows and some Mac users, this command may not be available. No worries: for the record, it shows that git generates a SHA1 of the committed files to store them in the repository. This command should display `64e3fc24e6ed73f1af43ae4e0411d80c10c4d0f7`.
*If you do not have the `shasum` command, don't run the command above and just go ahead with the following*.

Then execute : 

[source]
git ls-tree master

* What's the role of the ls-tree command?
* Compare the ls-tree output and the echo command output above. Conclude about how Git stores blobs.


* Create a new directory, copy the `pof` file inside it, `git add` the whole directory and commit it. 

[source]
mkdir newdirectory
cp pof newdirectory
git add newdirectory
git commit -m "Added the new subdirectory"

* Use `git ls-tree master` again to understand how the storage works (cf. slides)
* Use `git ls-tree` on the subdirectory to display its content (_hint:_ ls-tree takes a hash as parameter, not directory name). 
** What's the sha of the `pof` in that directory file?

NOTE: There's two categories of Git commands: 
      `porcelain` (example: git `checkout`) and
      `plumbing` (example: git `ls-tree`). These categories actually respectively relate to high-level (user-oriented) and low-level commands. 

TIP: To remember which is one: just remember, in toilets, are you more in contact with the porcelain or the plumbing?

== Rewriting

CAUTION: For this workshop, you need to use repository `git-next-level-workshop-rewriting.git` (workshop resources).

=== Playing with rebase
==== Basics
See <<rebaseInteractiveBasics>> first and along the lab if needed.

==== Let's start

* Open your shell, `cd` to the git workshop repository, list all commits.

CAUTION: Respect the steps order of the following. If you don't, you may change commit SHA-1 and not be able to find the SHA-1 given below.

. The three last commits ("Add jumbotron (partXXX)") are not consistent separately, merge these commits to create only one (and remove the useless _(partXXX)_ part of the commit log).
.. (For reference: first commit SHA-1 shortened version	 = `fc3034f86`)
. Manipulate the two following commits in the same interactive rebase :
.. Commit fe9ba27 is an inconsistent commit. Two different modifications have been made : the first adding a footer and the another correcting the header added in the precedent commit.
.. Commit 05a2231 is a correction of commit fe9ba27 (this sha1 has been changed during precedent action). Merge these two commits to create only one.
Split this commit to move header correction in the precedent commit and keep footer addition in two distinct and consistent commits.
. Commit dbb8f26 has a spelling error. Fix it.

=== Playing with dangling commit

Execute this command : 
[source]
git checkout fe9ba27

This commit has been modified during precedent actions. But you can still check it out.

* How does Git keep track of it?
* Explain why.

=== Playing with "cherry-pick"

The current repository has a branch named "header-black-experiment".
Execute : 
[source]
git checkout header-black-experiment

* List all commits.
* Using cherry-pick command, try to retrieve commit edcdd0a on the master branch

== Bonus Track

IMPORTANT: Do that part only if you finished everything above.

=== Garbage collect all the things

NOTE: Having a GC is very hype those days. Git has one too! Git GC will actually execute automatically under some conditions (too many loose/dangling objects, too many branches/tags...). You generally won't run it manually like in the next part.

* Execute `ls .git && ls -l .git/refs/heads` at your test repository root
* Execute `git gc --aggressive --prune=now`
* See what it changed. Explain the goal of the created file.


''''

== Annex

[[rebaseInteractiveBasics]]
=== rebase -i basics
TIP: Most instructions below require the use of: 

[source]
git rebase -i <COMMIT SHA>

[TIP]
====
When doing an interactive rebase
footnote:[The SHA you have to use is the *excluded*Â point from where the history twiddling will start. 
That is: if the first commit you want to modify is `12eaf` then use for example simply `12eaf~` to easily refer to the previous one. 
If you just want to potentially rewrite about the 5 last commits, then you'll generally use `git rebase -i HEAD~5`.],
read what's displayed inside your editor

[source]
----
$ git rebase -i HEAD~
pick 3262d5a ...

# Rebase 0345973..76e0b82 onto 0345973
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented ou
----

Read what's above. You *can* reorder commits by just *moving lines up or down*, or removing commits by just *removing a whole line*.
====

CAUTION: `git rebase -i` will display commits in chronological order, contrary to `git log`

=== Rolling back if required

If you want to just rollback any modification you made: use `reflog`, find the previous correct `HEAD` SHA, then reset your working copy to it

    $ git reset --hard <SHA>

For example, if you want to rollback everything to the initial state, just run 

    $ git reset --hard fc30